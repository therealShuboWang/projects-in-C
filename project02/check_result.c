/* ***********************************************************************************************************************************
 * *************************************************************** 判断输赢模块 ******************************************************
 * ***********************************************************************************************************************************/

#include "header.h"

Type check_result(int x, int y)
{
    /*
     * 定义判断输赢时需要的三个变量：
     * 变量count表示连在一起的同色棋子的个数：初始值设置为1，即表示以该棋子的颜色作为判断标准
     * 变量i表示棋子映射在二维数组中的行坐标：通过对i进行自增自减变化来定位周围的棋子
     * 变量j表示棋子映射在二维数组中的列坐标：通过对j进行自增自减变化来定位周围的棋子
     */
    int count = 1;
    int i = x;
    int j = y;

    /* ******************************************************************************************************************************
     * 以(x, y)位置上的棋子为判断标准，检查落子处所在的行是否出现五子连线                                                           *
     * ******************************************************************************************************************************/
    j = y + 1;                                  /* 向右检查是否有连在一起的同色棋子及其个数 */
    while (j < N && count < 5)                  /* 没有到达棋盘的右边界，同时连在一起的同色棋子的个数也没有达到5个时：继续向右检查 */
    {
        if (pieces[i][j] == pieces[x][y])       /* 每检查到右边有一个连在一起的棋子是同色的，就给变量count自增1 */
            count++;
        else
            break;                              /* 一旦发现一个连在一起的棋子不同色，则向右的检查立即结束；保留变量count的当前值，并从初始位置开始向左检查 */
        j++;
    }

    j = y - 1;                                  /* 向左检查是否有连在一起的同色棋子及其个数 */
    while (j >= 0 && count < 5)                 /* 没有到达棋盘的左边界，同时连在一起的同色棋子的个数也没有达到5个时：继续向左检查 */
    {
        if (pieces[i][j] == pieces[x][y])       /* 每检查到左边有一个连在一起的棋子是同色的，就给变量count自增1 */
            count++;
        else
            break;                              /* 一旦发现一个连在一起的棋子不同色，则向左的检查立即结束，同时意味着棋子所在行的检查结束 */
        j--;
    }

    /*
     * 判断落子处所在行是否出现五子连线，有三种可能的情况：
     * 情况一：落子处向右连着5个棋子为同色：这种情况下只会执行第一个while循环，循环执行4次，每次都能找到右邻的同色棋子，count也由1自增到5，在即将执行第5次循环时由于count不满足循环条件而退出
     *                                      同时也是因为count的值已经等于5而直接跳过第2个while循环，即没有向左检查的必要
     * 情况二：落子处向左连着5个棋子为同色：这种情况下第一个循环执行一次就会利用break语句跳出，此时count的值仍为1，代表还没有找到1个连在一起的同色棋子
     *                                      然后执行第2个循环向左检查，循环执行4次，每次都能找到左邻的同色棋子，count的值也由1自增到5，在即将执行第5次循环时由于count不满足循环条件而退出
     * 情况三：落子处左右各有几个棋子为同色：这是最普遍的情况，这种情况下两个while循环都会被执行，执行总次数加起来为4次
     *                                       count变量是最核心的控制条件
     */
    if (count == 5)
        return pieces[x][y];                    /* 如果出现五子连线的情况，我们通过返回落子处棋子的类型，确定游戏的赢家（棋子类型与执棋人是绑定的) */


    /* ******************************************************************************************************************************
     * 以(x, y)位置上的棋子为判断标准，检查落子处所在的列是否出现五子连线                                                           *
     * ******************************************************************************************************************************/
    count = 1;
    i = x;
    j = y;

    i = x + 1;                                  /* 向下检查是否有连在一起的同色棋子及其个数 */
    while (i < N && count < 5)
    {
        if (pieces[i][j] == pieces[x][y])
            count++;
        else
            break;
        i++;
    }

    i = x - 1;                                  /* 向上检查是否有连在一起的同色棋子及其个数 */
    while (i >= 0 && count < 5)
    {
        if (pieces[i][j] == pieces[x][y])
            count++;
        else
            break;
        i--;
    }

    if (count == 5)
        return pieces[x][y];




    /* ******************************************************************************************************************************
     * 以(x, y)位置上的棋子为判断标准，检查落子处所在的左斜线是否出现五子连线                                                       *
     * ******************************************************************************************************************************/
    count = 1;
    i = x;
    j = y;

    i = x - 1;
    j = y - 1;                                  /* 向左斜往上检查是否有连在一起的同色棋子及其个数 */
    while (i >= 0 && j >= 0 && count < 5)
    {
        if (pieces[i][j] == pieces[x][y])
            count++;
        else
            break;
        i--;
        j--;
    }

    i = x + 1;
    j = y + 1;                                  /* 向左斜往下检查是否有连在一起的同色棋子及其个数 */
    while (i < N && j < N && count < 5)        
    {
        if (pieces[i][j] == pieces[x][y])
            count++;
        else
            break;
        i++;
        j++;
    }

    if (count == 5)
        return pieces[x][y];



    /* ******************************************************************************************************************************
     * 以(x, y)位置上的棋子为判断标准，检查落子处所在的右斜线是否出现五子连线                                                       *
     * ******************************************************************************************************************************/
    count = 1;
    i = x;
    j = y;

    i = x - 1;
    j = y + 1;                                  /* 向右斜往上检查是否有连在一起的同色棋子及其个数 */
    while (i >= 0 && j < N && count < 5)
    {
        if (pieces[i][j] == pieces[x][y])
            count++;
        else
            break;
        i--;
        j++;
    }

    i = x + 1;
    j = y - 1;                                  /* 向右斜往下检查是否有连在一起的同色棋子及其个数 */
    while (i < N && j >= 0 && count < 5)
    {
        if (pieces[i][j] == pieces[x][y])
            count++;
        else
            break;
        i++;
        j--;
    }

    if (count == 5)
        return pieces[x][y];
    
    return NONE;                                /* 四个方向都没有形成五子连线的情况下，返回0 */
}






















