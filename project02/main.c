/* ***********************************************************************************************************************************
 * ************************************************************** 主函数模块 *********************************************************
 * ***********************************************************************************************************************************/

#include "header.h"
#include <unistd.h>

/*
 * 定义全局变量
 * 定义Type类型的全局变量pieces表示棋盘，并初始化棋盘状态为空
 * 定义Player类型的全局变量player表示玩家，并初始化游戏状态为由玩家A先行
 */
Type pieces[N][N] = {NONE};
Player player = A;        

int main(void)
{
    welcome();                                                      /* 显示欢迎界面 */
    draw_board();                                                   /* 显示棋盘界面 */
    
    int count_pieces = 0;                                           /* 定义变量表示棋盘上已经落子的数目 */
    while (count_pieces < N * N)                                    /* 当棋盘还未被填满时，玩家可以继续下棋 */
    {
        /*
         * 第一步：获取落子的位置
         * 定义变量x和y将棋子实际的行列位置映射为数组上的行列坐标
         * 在获取落子位置时，通过全局变量player的值确定执行此次落子操作的玩家，并向外输出提示信息
         */
        int x = get_row_coord() - 1;
        int y = get_column_coord() - 1; 

        if (pieces[x][y] == NONE)                                   /* 只有当玩家选定的位置没有棋子时才可以落子 */
        {
            /*
             * 第二步：进行落子操作
             * 由于玩家与其所用的棋子是绑定在一起的（玩家A执黑子，玩家B执白子）
             * 因此全局变量player不仅能直接确定执行此次落子操作的玩家，也能间接确定该位置应落棋子的类型 
             * 因此如果player的值为A，表明该玩家A进行落子操作，也间接表明该落的子为黑子
             *     如果player的值为B，表明该玩家B进行落子操作，也间接表明该落的子为白子
             * 完成落子操作后，更改表示当前已落子数目的变量count_pieces和表示执行下一次落子操作的玩家的变量player
             * 在进行游戏状态判断前重画棋盘，使得玩家始终看到最新的棋盘状态
             */
            if (player == A)
                pieces[x][y] = BLACK;
            else if (player == B)
                pieces[x][y] = WHITE;
            count_pieces++;
            player = (player == A) ? B : A;
            draw_board();


            /*
             * 第三步：判断此时游戏的状态
             * 调用check_results()函数分析落子后游戏是否分出了胜负，如果分出了胜负那么赢家是谁
             * check_results()函数的返回值类型为Type，具体的取值只有三种可能；又因为棋子与执棋的玩家是绑定在一起的
             * 因此如果返回值为BLACK，表示黑子已经五子连线，也间接表明执黑子的玩家A获胜，游戏结束
             *     如果返回值为WHITE，表示白子已经五子连线，也间接表明执白子的玩家B获胜，游戏结束
             *     如果返回值为NONE，表示任意一方都没有出现五子连线的现象，游戏继续（如果棋盘还未被填满）
             */
            Type result = check_result(x, y);
            if (result == BLACK)
            {
                printf("玩家A获胜！\n");
                sleep(3);
                break;
            }
            else if (result == WHITE)
            {
                printf("玩家B获胜！\n");
                sleep(3);
                break;
            }
        }
        else                                                        /* 当玩家选定的位置已经有棋子时输出错误提示消息，并重新输入 */
        {
            printf("该位置已有棋子！请按任意键后重新输入\n");
            getchar();
        }
    }

    /*
     * 有两种跳出while循环的方式，分别代表游戏所处的两种结束状态：
     * 第一种：while循环一直运行到不满足循环条件时才跳出
     *         此时棋盘已被棋子填满，游戏以和棋状态结束
     * 第二种：while循环执行到某一次时，由于产生了赢家而执行break语句直接跳出
     *         此时游戏以分出胜负而结束
     */
    if (count_pieces == N * N)
        printf("棋盘已被填满，和棋！\n");
    game_over();

    return  0;
}





















