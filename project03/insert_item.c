/* *******************************************************************************************************************************************
 * ************************************************************* 录入图书模块 ****************************************************************
 * *******************************************************************************************************************************************/

#include "header.h"
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

/* 函数原型 */
void create_book(void);
bool verify_existence(int number);

/* 函数定义 */

/*
 * 函数名称：create_book()
 * 函数作用：将用户录入的图书信息整合在一起形成一个图书结构体；将所有图书结构体连接起来形成一个图书链表
 * 该链表由两个指针变量head和tail进行起始位置和末尾位置的标记，对该链表的所有操作都是通过这两个指针变量的定位来完成的
 * 由于head和tail是共享变量：函数不需要设置对应的参数进行值传递就可以直接在函数内部使用
 * 由于head和tail是指针变量：在函数内部对它们做的修改一样会在函数外生效
 */
void create_book(void)
{
    /*
     * 由于程序允许用户一次录入多本图书的信息，因此程序采用永真循环while(true)反复执行同样的录入操作
     * 程序规定当用户输入的图书编号为0时，表示用户希望结束录入操作，这种情况下程序内部的break语句会被执行从而结束循环
     * while循环内部按逻辑分成三大部分操作：
     * 1. 使用函数内部变量接收用户录入的图书信息（在这一步中还会进行判断是否继续输入和输入是否合法的两个子操作）
     * 2. 动态分配内存空间创建结构体，将暂存在函数内部变量中的图书信息存储到结构体中对应的成员中
     * 3. 将创建好的图书结构体添加进图书链表中（如果创建的是第一个结构体则进行创建链表的操作）
     */
    while (true)
    {
        /* **********************************************************************************
         * 执行第一步操作：使用函数内部变量接收用户录入的图书信息                           *
         * **********************************************************************************/
        int number;
        char name[LEN], writer[LEN], press[LEN], category[LEN], time[LEN];
        double price;

        printf("请输入图书编号：");
        scanf("%d", &number);
        getchar();

        /*
         * 执行第一步中的第一个子操作：判断是否继续输入
         * 如果用户输入的图书编号为0，则执行break语句结束循环；否则跳过该语句继续向后执行进一步的判断
         */
        if (number == 0)
        {
            printf("录入操作结束！\n");
            sleep(1);
            break;
        }

        /*
         * 执行第一步中的第二个子操作：判断输入是否合法
         * 图书管理系统规定图书编号是唯一的，不允许重复。调用函数verify_existence()遍历链表，检查用户输入的图书编号信息是否已经存在
         * 如果输入合法，则继续其它信息的录入；如果输入不合法，则反复执行该while小循环直到输入的编号信息合法为止
         */
        while (verify_existence(number))
        {
            printf("您输入的编号已存在，请重新输入：");
            scanf("%d", &number);
            getchar();
        }
        printf("请输入图书名：");
        scanf("%s", name);
        printf("请输入作者名：");
        scanf("%s", writer);
        printf("请输入出版社：");
        scanf("%s", press);
        printf("请输入图书所属种类：");
        scanf("%s", category);
        printf("请输入出版时间：");
        scanf("%s", time);
        printf("请输入图书价格：");
        scanf("%lf", &price);


        /* **********************************************************************************
         * 执行第二步操作：创建结构体并用函数内部变量为结构体成员赋值                       *
         * **********************************************************************************/
        Book *p = malloc(sizeof(Book));
        
        p->number = number;
        strcpy(p->name, name);
        strcpy(p->writer, writer);
        strcpy(p->press, press);
        strcpy(p->category, category);
        strcpy(p->time, time);
        p->price = price;

        p->next = NULL;
        

        /* **********************************************************************************
         * 执行第三步操作：将创建好的结构体添加进图书链表中                                 *
         * **********************************************************************************/

        /*
         * 情况一：链表为空
         * 让头指针和尾指针都指向刚创建好的、唯一的一个结构体，该结构体内部的指针指向NULL
         */
        if (head == NULL)
        {
            head = tail = p;
            printf("录入成功！\n");
            sleep(1);
        }

        /*
         * 情况二：链表不为空
         * 由于我们采用双指针控制链表，两个指针的使用方法有所不同：
         * 头指针在初始化便保持不变，始终指向链表中的第一个结构体；尾指针则不断变化，将新创建的结构体添加进链表中
         */
        else
        {
            tail->next = p;
            tail = p;
            printf("录入成功！\n");
            sleep(1);
        }

    }

}

/*
 * 函数名称：verify_existence()
 * 函数作用：判断用户输入的图书编号是否已经存储在链表中的某个结构体中
 */
bool verify_existence(int number)
{
    /*
     * 将链表的状态分为三种可能形式，分别对应检查：
     * 可能形式一：链表为空：这种情况下一定不会有重复现象出现
     * 可能形式二：链表中有且仅有一个结构体：我们将这种特殊情况单独列出而不是归并到第三类中
     * 可能形式三：链表由多个(>=2)结构体构成：这种情况下我们必须通过遍历链表的方式逐一检查
     */
    
    /* 可能形式一：如果头指针指向NULL，则说明链表还未创建 */
    if (head == NULL)
        return false;

    /* 可能形式二：在形式一不满足的情况下，头尾指针指向的对象相等只可能在链表仅包含一个结构体的情况下出现 */
    if (head == tail)
        return head->number == number;
    
    /* 可能形式三：创建临时指针变量进行遍历链表的检查 */
    Book *temp = head;
    while (temp != NULL)
    {
        if (temp->number == number)
            return true;
        temp = temp->next;
    }
    return false;
}








